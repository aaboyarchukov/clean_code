# Время связывания переменных

Продолжаем впитывать полезные рекомендации.

Время связывания переменных - есть промежуток, между объявлением переменной и ее инициализацией, и главное здесь, что инициализация, может быть в любое время:

- Во время написания кода.

```
titleBar.color = 255;
```

- Во время компиляции программы.

```
private static final int COLOR_WHITE = 255;
// ...
titleBar.color = COLOR_WHITE;
```

- Во время исполнения программы + время вызова метода/функции.

```
titleBar.color = ReadTitleBarColor();
```

И тому подобные случаи, важно помнить одно, что:

> - чем позже вы выполняете связывание, тем более гибким будет ваш код, но и более сложным;  
> - чем раньше вы выполняете связывание, тем менее гибким будет ваш код, но и менее сложным.

Соответственно, проанализировав данный материал, можно сделать вывод о том, что переменные необходимо связывать на том уровне, который удовлетворяет требованиям, но не более, в противном случае, получится либо очень не гибкий код, либо чересчур сложный.

Задание:

[5_example1.go](https://github.com/aaboyarchukov/clean_code/blob/master/lesson12/5_example1.go)

```go
func (bf *BloomFilter) Hash1(s string) int {
    sum := 0
    const HASH_1_KOEFF int = 17
    // ...
    sum += code * HASH_1_KOEFF
    // ...
}
// В данном случае инициализация константы происходит при написании кода,
// так как это константа, которую мы используем, чтобы сделать функцию Hash1
// более гибкой.

log := SetupLoger("local")    
authConfig := auth_config.MustLoad()
authApllication := auth_app.New(log, authConfig.GRPC.Port)
authApllication.GRPCServer.MustRun()
// В следующих двух случаях переменные инициализируются на этапе компиляции
// так как переменная log - инициализирует logger сервиса, который при 
// необходимости надо настраивать, поэтому настройки вынесены в отдельную функцию,
// как и следующая переменная authConfig, которая из файла конфигурации достает
// необходимые для настройки и запуска сервера данные

func (s *authServerApi) Login(
    ctx context.Context,
    in *auth_v1.LoginRequest,
) (*auth_v1.LoginResponse, error) {

    // validate data
    errValidate := ValidateStringData(in.GetEmail(), in.GetPassword())
    if errValidate != nil {
        return nil, status.Error(codes.InvalidArgument, "email and password are required")
    }
    // some logic ...
}
// В данном случае инициализация переменной errValidate происходит при исполнении
// программы, сделано это для того, чтобы динамически отлавливать ошибки разного
// рода.
```

