# Типы данных


Продолжаем изучение

1. Приведение типов данных

Избегайте различных конвертаций типов их приведение, если это неизбежно, то делайте это максимально ясно.

2. Будьте осторожны при делении чисел

Всегда надо проверять делитель на 0, чтобы избежать ошибок и сбоев.

3. Сравнение разных типов данных

В любом виде избегайте сравнения разных типов данных! Это приводит к ошибкам.

4. Проверяйте целочисленность операций деления 

То есть при делении чисел необходимо использовать нужные операторы, чтобы не было ошибок с типами данных

5. Проверяйте переполнение целых чисел

Ваше объявленные целочисленные переменные могут легко переполнится, если неправильно указать для них тип данных с нужным размером. Также важно проверять на переполнение и промежуточные вычисления.

6. Вещественные числа

- Максимально постарайтесь исключить проверки вещественных чисел напрямую, необходимо искать минимальную разницу между ними.
- Избегайте вычислительных операций со слишком разными по величине вещественными числами 
- Предупреждайте ошибки округления
- Используйте более точные вещественные числа
- Измените значение вещественных чисел на целые, если это возможно

7. Строки и символы

- Локализируйте текстовые сообщения, чтобы они у вас не висели функциях по нескольку строк
- Используйте константы и избегайте магических символов и строк, также важное правило: объявлять константу/шаблон строки максимально близко к контексту использования, а также шаблоны лучше инкапсулировать внутрь функции с параметрами, а если же шаблон слишком большой, то лучше его обернуть в отдельный класс с чистым API
- Используйте один формат для строк  - лучше всего Unicode

8. Использование булевых выражений

Если ваши булевы выражения внутри условных операторов громоздкие, то лучшим решением будет обернуть их в отдельную переменную с ясным названием, а затем использовать в коде. Так повысится читабельность и ясность кода, не придется тратить лишнее время на переключение фокуса, чтобы понять, что делает то или иное условное выражение.

Например:

```go
// bad example ❌
if a > b && b <= c || c + 100 > 90 {
	// some action
}

// good example ✅
var finished bool = elementIndex < 0 || elementIndex > MAX_ELEMENTS;
var repeatedEntry bool = ( elementIndex == lastElementIndex ) 
if finished || repeatedEntry {
	// some action
}
```


Задания: 

[6_example1.go](https://github.com/aaboyarchukov/clean_code/blob/master/lesson9/6_example1.go)

```go
// одной задачей на работе было формировать excel файлы, в которых
// присутствовало много текстовых сообщений
// я придумал нехитрый алгоритм для их локализации
// пример текстового файла:
"""
KEY1=some_text
---
KEY2=some_text
---
KEY3=some_text
"""
// обычный текстовый файл разбивался на ассоциативный массив,
// а значение доставалось по ключу
const (
    INDX_KEY = iota
    INDX_VALUE
)
func Contain(value string) string {
    textMap := make(map[string]string)
    filePath, _ := os.LookupEnv("INFO_TXT")
    
    fileData, err := os.ReadFile(filePath)
    if err != nil {
        log.Println(err)
        return ""
    }

    stringData := string(fileData)
    arrRows := strings.Split(stringData, "---")
    for _, item := range arrRows {
        item = strings.TrimSpace(item)
        pairItems := strings.Split(item, "=")
        pairKey := pairItems[INDX_KEY]
        pairValue := pairItems[INDX_VALUE]
        textMap[pairKey] = pairValue
    }
    return textMap[value]
}
// также в этой функции можно сделать изменения

--- - LINE_SEPARATOR
= - KEY_VALUE_SEPARATOR
// заменил магические строки на понятные константы

const (
    INDX_KEY = iota
    INDX_VALUE
)
func Contain(value string) string {
    textMap := make(map[string]string)
    filePath, _ := os.LookupEnv("INFO_TXT")
    
    fileData, err := os.ReadFile(filePath)
    if err != nil {
        log.Println(err)
        return ""
    }

    stringData := string(fileData)
    arrRows := strings.Split(stringData, LINE_SEPARATOR)
    for _, item := range arrRows {
        item = strings.TrimSpace(item)
        pairItems := strings.Split(item, KEY_VALUE_SEPARATOR)
        pairKey := pairItems[INDX_KEY]
        pairValue := pairItems[INDX_VALUE]
        textMap[pairKey] = pairValue
    }
    return textMap[value]
}

tempNode.value == n - equalValue
// заменил не ясное булевое выражение на ясную переменную,
// которая хранит значение выражения, тем самым улучшив
// читаемость кода

l.Count() == 1 - oneNodeInLinkedList
// заменил не ясное булевое выражение на ясную переменную,
// которая хранит значение выражения, тем самым улучшив
// читаемость кода

tempNode == l.head - equalHead
// заменил не ясное булевое выражение на ясную переменную,
// которая хранит значение выражения, тем самым улучшив
// читаемость кода

tempNode == l.tail - equalTail
// заменил не ясное булевое выражение на ясную переменную,
// которая хранит значение выражения, тем самым улучшив
// читаемость кода

'.' - FLOAT_NUMBER_SEPARATOR
// выделил магический символ в константу для ясности

string(symbol) == "." - symbol == FLOAT_NUMBER_SEPARATOR
// избавился от ненужного приведения данных

0.0001 - ERROR_RATE
// ввел константу для погрешности и улучшил ясность, избавился от
// магических чисел

firstNumber == secondNumber - difference < ERROR_RATE
// исправил сравнение двух вещественных чисел
// с помощью определения их разности и сравнение с погрешностью
// таким образом мы учитываем погрешность, что уменьшает риск ошибиться

secondSide == 0
// добавил проверку на 0 - исключил возникновение ошибок при делении

-1 - RETURN_WRONG_FLOAT
// добавил константу и избавился от магических цифр

"devide by zero" - ERROR_TEXT
// добавил константу и избавился от магической строки

floatFirstSide := float64(firstSide)
floatSecondSide := float64(secondSide)
// вынужденное приведение типов, так как ищем синус с помощью двух сторон
// обозначил их отдельными переменными для лучшей ясности

floatFirstSide / floatSecondSide -> sin
// обозначил нахождение синуса в отдельную переменную, а не вынес 
// в возращаемое значение, улучшил читаемость и ясность

```